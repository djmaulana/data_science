# -*- coding: utf-8 -*-
"""TuproAI2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wC-ZQ0GEeqmZVPvXI53M96X6llinIX6A

LIBRARY
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from google.colab import files

"""READ DATA"""

# upload dulu file restoran.xlsx
uploaded = files.upload()

data = pd.read_excel('restoran.xlsx', index_col = 'id')
print(data.head(50))

"""TRIANGULAR MEMBERSHIP FUNCTION GENERATOR"""

def segitigaMode(x, abc):
    assert len(abc) == 3, 'abc parameter must have exactly three elements.'
    a, b, c = np.r_[abc]     # Zero-indexing in Python
    assert a <= b and b <= c, 'abc requires the three elements a <= b <= c.'

    y = np.zeros(len(x))

    # Left side
    if a != b:
        idx = np.nonzero(np.logical_and(a < x, x < b))[0]
        y[idx] = (x[idx] - a) / float(b - a)

    # Right side
    if b != c:
        idx = np.nonzero(np.logical_and(b < x, x < c))[0]
        y[idx] = (c - x[idx]) / float(c - b)

    idx = np.nonzero(x == b)
    y[idx] = 1
    return y

"""DEGREE OF MEMBERSHIP FUNCTION"""

def interp_membership(x, xmf, xx, zero_outside_x=True):
    #untuk memberi nilai 
    if not zero_outside_x:
        kwargs = (None, None)
    else:
        kwargs = (0.0, 0.0)
    return np.interp(xx, x, xmf, left=kwargs[0], right=kwargs[1])

"""DEFUZZIFICATION OF A MEMBERSHIP FUNCTION"""

def centroid(x, mfx):
   
    sum_moment_area = 0.0
    sum_area = 0.0

    # If the membership function is a singleton fuzzy set:
    if len(x) == 1:
        return x[0]*mfx[0] / np.fmax(mfx[0], np.finfo(float).eps).astype(float)

    # else return the sum of moment*area/sum of area
    for i in range(1, len(x)):
        x1 = x[i - 1]
        x2 = x[i]
        y1 = mfx[i - 1]
        y2 = mfx[i]

        # if y1 == y2 == 0.0 or x1==x2: --> rectangle of zero height or width
        if not(y1 == y2 == 0.0 or x1 == x2):
            if y1 == y2:  # rectangle
                moment = 0.5 * (x1 + x2)
                area = (x2 - x1) * y1
            elif y1 == 0.0 and y2 != 0.0:  # triangle, height y2
                moment = 2.0 / 3.0 * (x2-x1) + x1
                area = 0.5 * (x2 - x1) * y2
            elif y2 == 0.0 and y1 != 0.0:  # triangle, height y1
                moment = 1.0 / 3.0 * (x2 - x1) + x1
                area = 0.5 * (x2 - x1) * y1
            else:
                moment = (2.0 / 3.0 * (x2-x1) * (y2 + 0.5*y1)) / (y1+y2) + x1
                area = 0.5 * (x2 - x1) * (y1 + y2)

            sum_moment_area += moment * area
            sum_area += area

    return sum_moment_area / np.fmax(sum_area,
                                     np.finfo(float).eps).astype(float)
def defuzz(x, mfx, mode):

    mode = mode.lower()
    x = x.ravel()
    mfx = mfx.ravel()
    n = len(x)
    assert n == len(mfx), 'Length of x and fuzzy membership function must be \
                          identical.'

    if 'centroid' in mode or 'bisector' in mode:
        zero_truth_degree = mfx.sum() == 0  # Approximation of total area
        assert not zero_truth_degree, 'Total area is zero in defuzzification!'

        if 'centroid' in mode:
            return centroid(x, mfx)
    else:
        raise ValueError('The input for `mode`, %s, was incorrect.' % (mode))

"""FUZZIFICATION PROCESS"""

# Variable linguitas dengan batasan-batasan setiap inputan yaitu dari 1 sampai 100
x_makanan = np.arange(0, 101, 1)
x_pelayanan = np.arange(0, 101, 1)
x_rank  = np.arange(0, 101, 1)

# Nilai linguitas kita bagi menjadi 3 setiap variable yaitu low, medium, dan high
makanan_lo = segitigaMode(x_makanan, [0, 0, 50])
makanan_md = segitigaMode(x_makanan, [0, 50, 100])
makanan_hi = segitigaMode(x_makanan, [50, 100, 100])
pelayanan_lo = segitigaMode(x_pelayanan, [0, 0, 50])
pelayanan_md = segitigaMode(x_pelayanan, [0, 50, 100])
pelayanan_hi = segitigaMode(x_pelayanan, [50, 100, 100])
rank_lo = segitigaMode(x_rank, [0, 0, 50])
rank_md = segitigaMode(x_rank, [0, 50, 100])
rank_hi = segitigaMode(x_rank, [50, 100, 100])

# Visualize these universes and membership functions
fig, (ax0, ax1, ax2) = plt.subplots(nrows=3, figsize=(8, 9))

ax0.plot(x_makanan, makanan_lo, 'b', linewidth=1.5, label='Ga Enak')
ax0.plot(x_makanan, makanan_md, 'g', linewidth=1.5, label='Lumayan')
ax0.plot(x_makanan, makanan_hi, 'r', linewidth=1.5, label='Enak Banget')
ax0.set_title('Kalitas Makanan')
ax0.legend()

ax1.plot(x_pelayanan, pelayanan_lo, 'b', linewidth=1.5, label='Buruk')
ax1.plot(x_pelayanan, pelayanan_md, 'g', linewidth=1.5, label='Normal')
ax1.plot(x_pelayanan, pelayanan_hi, 'r', linewidth=1.5, label='Luar Biasa')
ax1.set_title('Kualitas Pelayanan')
ax1.legend()

ax2.plot(x_rank, rank_lo, 'b', linewidth=1.5, label='Bawah')
ax2.plot(x_rank, rank_md, 'g', linewidth=1.5, label='Tengah')
ax2.plot(x_rank, rank_hi, 'r', linewidth=1.5, label='Tinggi')
ax2.set_title('Rank')
ax2.legend()

# Turn off top/right axes
for ax in (ax0, ax1, ax2):
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()

plt.tight_layout()

"""INFERENSI"""

# INPUT DATA 
makanan_level_lo = interp_membership(x_makanan, makanan_hi, data['makanan']) 
makanan_level_md = interp_membership(x_makanan, makanan_md, data['makanan'])
qual_level_hi = interp_membership(x_makanan, makanan_lo, data['makanan'])

serv_level_lo = interp_membership(x_pelayanan, pelayanan_lo, data['pelayanan'])
serv_level_md = interp_membership(x_pelayanan, pelayanan_md, data['pelayanan'])
serv_level_hi = interp_membership(x_pelayanan, pelayanan_hi, data['pelayanan'])

# INFERENSI
low = []
md = []
hi = []
for i in range(len(data)):
  #mencari nilai tertinggi dari kualitas makanan dan kualitas pelayanan 
  active_rule1 = np.fmax(makanan_level_lo[i], serv_level_lo[i])
  # mencari nilai terendah dari hasil active rule 1 dan batasan rank rendah 
  rank_activation_lo = np.fmin(active_rule1, rank_lo)  
   # mencari nilai terendah dari kualitas pelayanan dan batasan rank sedang
  rank_activation_md = np.fmin(serv_level_md[i], rank_md) 
  # mencari nilai tertinggi dari kualitas makanan dan kualitas pelayanan 
  active_rule3 = np.fmax(qual_level_hi[i], serv_level_hi[i]) 
  rank_activation_hi = np.fmin(active_rule3, rank_hi) 
  tip0 = np.zeros_like(x_rank)
  # menampuang setiap nilai yang didapat
  low.append(rank_activation_lo)
  md.append(rank_activation_md)
  hi.append(rank_activation_hi)

"""OUTPUT DEFFUZIFICATION"""

arr = []
arr2 = []
arr3 = []
for j in range(len(data)):
  aggregated = np.fmax(low[j],
                     np.fmax(md[j], hi[j]))
  arr.append(aggregated)
# Menghitung hasil defuzz
  rank = defuzz(x_rank, arr[j], 'centroid')
  rank_activation = interp_membership(x_rank, arr[j], rank)  # for plot
  arr2.append(rank)
  arr3.append(rank_activation)
data['hasil'] = arr2
DataRank = data.sort_values('hasil', ascending=False).head(20)
DataRank.to_excel('peringkat.xls')
print(DataRank)